<html>
  <body style="margin: 0; background: black;">
    <div style="text-align: center;">
      <canvas id="canvas"></canvas>
    </div>
    <script src="dm.js"></script>
    <script>

'use strict';

let debug = true;

const juicedUpRectangle = new Rectangle(200, 200, 100, 35, 'orange');
juicedUpRectangle.origWidth = juicedUpRectangle.width;
juicedUpRectangle.origHeight = juicedUpRectangle.height;
juicedUpRectangle.step = function(t) {
  this.width = this.origWidth + 0.1 * this.origWidth * Math.sin(t / 60 / (2 * Math.PI));
  this.height = this.origHeight + 0.1 * this.origHeight * Math.cos(t / 60 / (2 * Math.PI));
};

const objects = [
  new Circle(100, 100, 25, 'blue'),
  new Circle(100, 200, 30, 'green'),
  new Rectangle(200, 100, 80, 40, 'cornflowerblue'),
  juicedUpRectangle
];

const beams = [];

const mouse = {
  x: -10,
  y: -10,
  buttonIsDown: false,
  targetObj: null,
  targetObjOffsetX: 0,
  targetObjectOffsetY: 0
};

const ctxt = canvas.getContext('2d');

canvas.onmousemove = e => {
  mouse.x = e.offsetX;
  mouse.y = e.offsetY;
  if (mouse.targetObj) {
    mouse.targetObj.x = mouse.x - mouse.targetObjOffsetX;
    mouse.targetObj.y = mouse.y - mouse.targetObjOffsetY;
  }
};

document.body.onmousedown = e => {
  mouse.buttonIsDown = true;
  mouse.targetObj = null;
  for (let idx = objects.length - 1; idx >= 0; idx--) {
    const obj = objects[idx];
    if (!mouse.targetObj && obj.containsPoint(mouse.x, mouse.y)) {
      mouse.targetObj = obj;
      mouse.targetObjOffsetX = mouse.x - obj.x;
      mouse.targetObjOffsetY = mouse.y - obj.y;
      objects.splice(objects.indexOf(obj), 1);
      objects.push(obj);
    }
  }
};

document.body.onmouseup = e => {
  mouse.buttonIsDown = false;
  mouse.targetObj = null;
};

let scheduledSends = [];

document.body.onkeydown = e => {
  if (e.code === 'Space') {
    debug = !debug;
    return;
  }
  if (!mouse.targetObj) {
    return;
  }
  const descriptor = new ReceiverDescriptor(mouse.targetObj);
  const maxDistance = e.shiftKey ? undefined : 100;
  switch (e.code) {
    case 'KeyW':
      descriptor.up(maxDistance);
      break;
    case 'KeyX':
      descriptor.down(maxDistance);
      break;
    case 'KeyA':
      descriptor.left(maxDistance);
      break;
    case 'KeyD':
      descriptor.right(maxDistance);
      break;
    case 'KeyS':
      descriptor.nearby(maxDistance);
      break;
    default:
      return;
  }
  const selector = 'infect';
  const args = [descriptor.direction];
  scheduledSends.push({descriptor, selector, args});
};

function seconds(s) {
  return new Promise(resolve => {
    setTimeout(resolve, s * 1000);
  });
}

let dir = 'nearby';
let dist = 100;
let t = 0;

async function main(t) {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  for (let obj of objects) {
    await obj.step(t);
  }
  t++;

  ctxt.clearRect(0, 0, canvas.width, canvas.height);
  for (let obj of objects) {
    obj.drawOn(ctxt);
  }

  if (scheduledSends.length > 0) {
    const {descriptor, selector, args} = scheduledSends.shift();
    await descriptor.send(selector, ...args);
  }

  requestAnimationFrame(main);
}

requestAnimationFrame(main);

    </script>
  </body>
</html>
